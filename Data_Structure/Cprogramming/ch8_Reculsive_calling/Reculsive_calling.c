/* 재귀 호출 : 자기 자신을 다시 호출하는 것이다.

재귀 호출의 해결하는 방법
    >> 분할 정복 : 복잡한 문제를 작고 단순한 문제로 나누어서 해결하는 방법

재귀 호출의 주의할 점
    >> 무한 루프에 빠지게 하면 안된다.
        1. 호출될 때마다 문제의 범위가 줄어들어야 한다.
        2. 종료 조건이 있어야 한다.

함수에서 사용되는 모든 지역 변수와 전달된 인자 등을 저장하는 공간을 활성 레코드 라고 한다.
    >> 어떤 함수에서 다른 함수가 호출되면 해당 함수의 활성 레코드로 변경시키는데 이를 문맥 변경 이라고 한다.

재귀 호출의 단점
    >> 상대적으로 속도가 느리다 : 문맥 변경에 추가적인 시간이 필요하다.
    >> 함수 호출 횟수에 제한이 있다 : 운영체제의 스택 크기에 제한이 있다. ex ) factorial(1)의 실행이 끝나면 시스템 스택에서 활성 레코드를 새로 팝(pop)하여
        다음에 실행할 함수를 로딩한다.
    >> 스택 오버플로 : 재귀 호출의 호출 횟수 초과 시 오류

재귀 호출과 반복 호출
    >> 재귀 호출 장점 : 알고리즘이 간결하며 명확하다.
    >> 반복 호출 장점 : 속도가 빠르고 시스템 메모리 사용이 작다. ( while , for )

*/

#include <stdio.h>

int factorial(int n)
{
    int ret = 0;
    if (n <= 1)
    {
        ret = 1;
    }
    else
    {
        ret = n * factorial(n - 1);
    }

    return ret;
}

int main(void)
{
    int input_value = 4;
    int result = 0;

    result = factorial(input_value);
    printf("%d! = %d\n",input_value, result);
}