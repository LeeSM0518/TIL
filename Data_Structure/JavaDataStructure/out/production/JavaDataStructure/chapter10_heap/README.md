# Chapter 09. 히프

**히프(heap)**

* 완전 이진 트리의 한 종류
* 중간 레벨에는 빈 노드가 없다.
* 최대 트리 혹은 최소 트리



# 1. 히프란?

* 루트 노드가 언제나 그 트리의 **최대값 혹은 최소값을** 가진다.
* 루트 노드가 최소값 => 최소 히프
* 루트 노드가 최대값 => 최대 히프



## 1.1. 최대 트리

**최대 히프**

* 트리의 모든 노드가 자신의 자식 노드보다 그 값이 크거나 같다.

<img src="../capture/스크린샷 2019-06-20 오전 11.36.20.png" width=500>



**최소 히프**

* 각 노드의 값이 자식 노드의 키 값보다 작거나 같다.

<img src="../capture/스크린샷 2019-06-20 오전 11.37.03.png" width=500>



## 1.2. 완전 이진 트리

히프는 최소 트리 혹은 최대 트리의 특성이 있지만, **완전 이진 트리여야만** 한다.

* **완전 이진 트리** : 높이가 h라고 했을 때, 레벨 1부터 레벨 h-1까지는 <u>포화 이진 트리와</u> 마찬가지로 꽉 채워져 있다가, 마지막 <u>레벨 h에서는 왼쪽에서 오른쪽으로 노드가 채워져 있는</u> 이진 트리이다. 마지막 레벨에서는 <u>중간에 빈 노드가 없다.</u>

<img src="../capture/스크린샷 2019-06-20 오전 11.48.13.png" width=600>



## 1.3. 히프의 정의

**히프의 루트 노드의 특성**

| 구분                | 조건                                         | 루트 노드의 키 값   |
| ------------------- | -------------------------------------------- | ------------------- |
| 최대 히프(Max Heap) | (부모의 노드의 키 값) >= (자식 노드의 키 값) | 트리 전체 중 최댓값 |
| 최소 히프(Min Heap) | (부모의 노드의 키 값) <= (자식 노드의 키 값) | 트리 전체 중 최소값 |



참고로 히프의 루트 노드를 제외하고서는 **느슨한 정렬 상태를** 유지한다.

* **느슨한 정렬 상태**
  * 각 노드가 모든 하위 레벨의 노드보다 크거나 같지는 않다. 즉, 느슨하기 때문에 모든 하위 레벨의 노드에 대해서 <u>완벽하게 만족하지 않는다.</u>

<img src="../capture/스크린샷 2019-06-20 오전 11.55.58.png" width=500>



# 2. 히프의 추상 자료형

| 기능      | 이름         | Input       | Output    | 설명                                      |
| --------- | ------------ | ----------- | --------- | ----------------------------------------- |
| 히프 생성 | createHeap() | 히프의 크기 | 히프      | 최대 n 개의 원소를 가질 수 있는 히프 생성 |
| 히프 삭제 | deleteHeap() | 히프        | N/A       | 히프 제거                                 |
| 자료 추가 | insertHeap() | 히프, 자료  | 성공/실패 | 히프에 새로운 자료 추가                   |
| 자료 제거 | removeHeap() | 히프        | 노드      | 히프의 루트 노드를 제거한 뒤 반환         |



# 3. 최대 히프에서의 추가 연산

## 3.1. Step-1) 트리의 마지막 자리에 임시 저장

히프에 새로운 노드가 추가되면, 새로운 노드는 먼저 트리의 **가장 마지막 자리에** 임시로 저장한다. 

<img src="../capture/스크린샷 2019-06-20 오후 12.21.16.png">



## 3.2. Step-2) 부모 노드와 키 값 비교와 이동

최대 트리 일때는 **(부모 노드의 키 값) >= (자식 노드의 키 값)** 조건을 갖추기 위해 새로 추가된 노드와 이 노드의 부모 노드 사이의 값을 비교해야 한다.

만약 새로 추가된 노드의 키 값이 더 크다면 새로 추가된 노드와 부모 노드와 위치를 교환해 준다.

<img src="../capture/스크린샷 2019-06-20 오후 1.31.23.png" width=500>

이렇게 한 번 위치를 변경한 이후에도 여전히 부모 노드의 값보다 **추가된 노드의 값이 더 클 때에는** 한 번 더 노드의 위치를 교환해 준다. 그러면 **완전 이진 트리에다가 최대 트리** 조건을 모두 만족하게 했기 때문에 최대 히프에서의 삽입 연산이 완료된다.



# 4. 히프에서의 제거 연산

**최대 히프의 제거 연산 = 최대값의 반환 연산** , 왜냐하면 히프에서는 오직 현재 루트 노드만 제거하기 때문이다.

그런데 원래 있던 루트 노드가 제거되더라도 히프는 여전히 히프여야 한다. 즉, 제거된 루트 노드를 대체하여 **새로운 루트 노드를 만드는 등의 후처리 과정(post processing)이** 필요하다.



## 4.1. Step-1) 루트 노드의 제거

최대 히프인 경우에는 루트 노드의 값이 히프 내에서 **최댓값이며,** 최소 히프의 루트 노드 값은 **최솟값입니다.**

<img src="../capture/스크린샷 2019-06-20 오후 1.47.14.png">



## 4.2. Step-2) 트리 마지막 자리 노드의 임시 이동

삽입 연산과 마찬가지로 트리의 **가장 마지막에 있는 노드를** 임시로 루트 노드 위치로 이동시킨다. 즉, 히프는 완전 이진 트리이기 때문에 **가장 높은 레벨의 가장 오른쪽 노드를 제거하여** 루트 노드의 위치로 이동시킨다.

<img src="../capture/스크린샷 2019-06-20 오후 1.49.55.png">



## 4.3. Step-3) 자식 노드들과의 값 비교와 이동

최대 트리의 조건을 만족하기 위해서 현재 루트 노드와 자식 노드의 위치를 서로 교환해야 한다. 그래서 **부모 노드의 값이 자식 노드의 값보다 크도록** 만들어 준다. 이때 두 개의 자식 노드 중에서 **키 값이 더 큰 노드와** 부모 노드를 교환해 준다.

<img src="../capture/스크린샷 2019-06-20 오후 1.53.24.png">

그 후, 이처럼 **완전 이진 트리이면서** 동시에 각 노드의 키 값이 자식 노드의 키 값보다 큰 **최대 트리가** 된다.



**함수의 시간 복잡도**

* **새로운 자료 추가** : O(logN)
* **최소(최대) 자료 제거** : O(logN)

> **완전 이진 트리 형태이기** 때문에 자료의 개수가 **N** 개인 경우에 트리의 높이가 **logN** 이다. 그러므로 위와 같은 시간 복잡도가 가지게 된다.



# 5. 히프의 구현

**배열 이진 트리를 기반으로 최대 히프 구현**

* 배열을 이용하면 히프에서 부모 노드와 자식 노드를 바로 찾을 수 있다. 왜냐하면, **완전 이진 트리이기** 때문에 노드별로 부여된 **배열 인덱스 값에 다음과 같은 규칙이 적용된다.**



1. 노드 i의 부모 노드 인덱스 = **(하한) i / 2, 단 i > 1**
2. 노드 i의 왼쪽 자식 노드 인덱스 = **2 * i**
3. 노드 i의 오른쪽 자식 노드 인덱스 = **(2 * i) + 1**

> i = 위치 인덱스
>
> (하한) = 소수점 버림 , **ex) (하한) 3.5 = 3**



## 5.1. 최대 히프의 구조

```java
package chapter10_heap;

public class Heap<T> {
  
	private int[] nodes;        // 노드 배열
  private int maxCount;       // 최대 자료 개수
  private int currentCount;   // 현재 자료 개수
  
}
```



## 5.2. 히프의 생성

```java
package chapter10_heap;

public class Heap<T> {
  
  private T[] nodes;          // 노드 배열
  private int currentCount;   // 현재 자료 개수

  public Heap(int maxCount) {
    this.maxCount = maxCount;
    nodes = new int[maxCount+1];
  }

}
```

> 배열의 마지막 원소의 위치 인덱스가 maxCount-1이 아니라 maxCount라는 점에 주의해야 한다. 왜냐하면 히프에서는 **0번째 인덱스는 사용하지 않기 때문이다.**



## 5.3. 최대 히프에서의 추가 연산

```java
public void insertMaxHeap(final int value) {
  if (currentCount == maxCount) {
    System.out.println("히프가 가득 찼습니다.");
  } else {
    // 현재 노드 개수를 1 증가시켜, 히프 마지막 노드의 위치를 가리키도록 한다.
    int i = ++currentCount;

    // 추가할 값이 부모 노드보다 클 경우 부모 노드와 위치를 바꾼다
    while (i != 1 && value > nodes[i/2]) {
      nodes[i] = nodes[i/2];
      i /= 2;
    }

    // 최종적으로 구한 위치에 새로운 값 삽입
    nodes[i] = value;
  }
}
```



## 5.4. 최대 히프에서의 제거 연산

```java
public int removeMaxHeap() {
  // 현재 히프가 비어있는지 점검
  if (currentCount == 0) {
    System.out.println("히프가 비어있습니다.");
    return 0;
  }

  // 루트 노드와 루트 노드의 왼쪽 자식 노드 인덱스
  int parent = 1, child = 2;
  // 반환되는 노드의 값으로 기존 루트 노드 저장
  int returnNode = nodes[parent];
  // 히프의 제일 마지막 노드의 인덱스를 저장하고,
  // 저장된 자료의 개수를 1 감소시킨다.
  int lastNodeIndex = currentCount--;

  while (child <= currentCount) {
    // 왼쪽 자식 노드보다 오른쪽 자식 노드의 키 값이 더 클때, 비교 대상 자식 노드 변경
    if (child < currentCount && nodes[child] < nodes[child+1]) child++;

    // 만약, 마지막 노드의 값이 현재 노드보다 더 크거나 같으면,
    // 바로 이 위치로 노드를 삽입하기 위해 break
		if (nodes[lastNodeIndex] >= nodes[child]) break;

    // 현재의 노드를 부모 노드의 위치로 한 칸 이동시키고, 다시 아래 레벨로 이동
    nodes[parent] = nodes[child];
    parent = child;
    child *= 2;
  }

  // 현재 위치 parent에 히프의 마지막 노드의 값을 대입
  nodes[parent] = nodes[lastNodeIndex];
  // 마지막 노드 값 제거
  nodes[lastNodeIndex] = 0;

  return returnNode;
}
```



## 5.5. 히프 순회

```java
public void displayHeap() {
  if (currentCount == 0) {
    System.out.println("히프가 비어있습니다.");
  } else {
    for (int i = 1; i <= currentCount; i++) {
      System.out.println("[" + i + "], " + nodes[i] );
    }
  }
  System.out.println();
}
```



# 6. 히프의 응용

## 6.1. 우선순위 큐

* 반환(dequeue) 시에 큐에서 **우선순위가 가장 높거나 혹은 가장 낮은** 노드를 먼저 반환하는 큐이다. 

* 우선순위 큐에서의 반환 순서는 삽입되는 순서와는 상관없으며 **오직 저장된 자료의 크기로** 결정된다.

> 만약, 최대 우선순위 큐를 기존의 리스트로 구현한다고 하면 자료의 삽입이나 삭제 연산의 시간 복잡도가 **O(N)** 이고, 히프를 사용하여 우선순위 큐를 구현하면 시간 복잡도가 **O(logN)** 이 되어 비교적 빠른 속도를 낼 수 있다.



## 6.2. 히프 정렬

**오름차순(ascending) 정렬** : 값이 증가하는 순서대로 배열하는 것

**내림차순(descending) 정렬** : 큰 값부터 시작하여 값이 감소하는 순서대로 배열하는 것



### 6.2.1. 히프 정렬의 구현

최대 히프를 이용하여 내림차순 정렬 구현

**코드**

```java
package chapter10_heap;

public class Sort {

  public static int[] heapSort (int[] intArray) {
    Heap heap = new Heap(intArray.length);
    int[] returnArray = new int[intArray.length];

    // 최대 히프 생성
    for (int i : intArray) {
      heap.insertMaxHeap(i);
    }

    // 값이 큰 순서대로 히프에서 값 가져와서 저장
    for (int i = 0; i < returnArray.length; i++) {
      returnArray[i] = heap.removeMaxHeap();
    }

    return returnArray;
  }

  public static void main(String[] args) {
    int[] arr = new int[]{1, 5, 3, 8, 9, 10, 4, 7};
    int[] sortedArr = heapSort(arr);

    for (int i : sortedArr) {
      System.out.println(i);
    }
  }
  
}
```

**실행 결과**

```
10
9
8
7
5
4
3
1
```